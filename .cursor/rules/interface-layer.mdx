# 接口层（Interface Layer）开发规范

## 核心原则

接口层负责处理外部请求和响应：
- **协议适配**：适配HTTP、gRPC、MCP等不同协议
- **请求验证**：验证和转换外部请求
- **错误处理**：统一错误响应格式
- **认证授权**：处理用户认证和权限控制

## 目录结构

```
internal/interfaces/
├── http/                # HTTP接口
│   ├── handler/         # HTTP处理器
│   │   ├── user_handler.go
│   │   ├── order_handler.go
│   │   └── health_handler.go
│   ├── middleware/      # 中间件
│   │   ├── auth.go
│   │   ├── logging.go
│   │   ├── cors.go
│   │   └── recovery.go
│   ├── request/         # 请求模型
│   │   ├── user_request.go
│   │   └── order_request.go
│   ├── response/        # 响应模型
│   │   ├── user_response.go
│   │   └── common.go
│   └── router.go        # 路由配置
├── grpc/                # gRPC接口
│   ├── handler/
│   │   └── user_handler.go
│   └── proto/
│       └── user.proto
├── mcp/                 # MCP协议接口
│   ├── handler/
│   │   └── mcp_handler.go
│   └── protocol/
│       └── protocol.go
└── websocket/           # WebSocket接口
    └── handler/
        └── realtime_handler.go
```

## HTTP接口实现

### 1. HTTP处理器
```go
package handler

import (
    "encoding/json"
    "net/http"
    
    "github.com/go-chi/chi/v5"
    "github.com/google/uuid"
)

// UserHandler 用户HTTP处理器
type UserHandler struct {
    userService *service.UserService
    logger      Logger
}

// NewUserHandler 创建用户处理器
func NewUserHandler(userService *service.UserService, logger Logger) *UserHandler {
    return &UserHandler{
        userService: userService,
        logger:      logger,
    }
}

// CreateUser 创建用户
func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // 1. 解析请求
    var req request.CreateUserRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        response.Error(w, http.StatusBadRequest, "invalid request body", err)
        return
    }
    
    // 2. 验证请求
    if err := req.Validate(); err != nil {
        response.Error(w, http.StatusBadRequest, "validation failed", err)
        return
    }
    
    // 3. 转换为命令
    cmd := command.CreateUserCommand{
        Email:    req.Email,
        Name:     req.Name,
        Password: req.Password,
    }
    
    // 4. 执行命令
    userID, err := h.userService.CreateUser(ctx, cmd)
    if err != nil {
        h.logger.Error("failed to create user", "error", err)
        response.Error(w, http.StatusInternalServerError, "failed to create user", err)
        return
    }
    
    // 5. 查询用户详情
    user, err := h.userService.GetUser(ctx, query.GetUserQuery{UserID: userID})
    if err != nil {
        response.Error(w, http.StatusInternalServerError, "user created but failed to retrieve", err)
        return
    }
    
    // 6. 返回响应
    response.JSON(w, http.StatusCreated, response.UserResponse{
        ID:        user.ID,
        Email:     user.Email,
        Name:      user.Name,
        Status:    user.Status,
        CreatedAt: user.CreatedAt,
    })
}
```

### 2. 请求模型
```go
package request

import "errors"

// CreateUserRequest 创建用户请求
type CreateUserRequest struct {
    Email    string `json:"email" validate:"required,email"`
    Name     string `json:"name" validate:"required,min=2,max=50"`
    Password string `json:"password" validate:"required,min=8"`
}

// Validate 验证请求
func (r *CreateUserRequest) Validate() error {
    if r.Email == "" {
        return errors.New("email is required")
    }
    if r.Name == "" {
        return errors.New("name is required")
    }
    if len(r.Name) < 2 || len(r.Name) > 50 {
        return errors.New("name must be between 2 and 50 characters")
    }
    if r.Password == "" {
        return errors.New("password is required")
    }
    if len(r.Password) < 8 {
        return errors.New("password must be at least 8 characters")
    }
    return nil
}
```

### 3. 响应模型
```go
package response

import (
    "encoding/json"
    "net/http"
    "time"
)

// UserResponse 用户响应
type UserResponse struct {
    ID        string    `json:"id"`
    Email     string    `json:"email"`
    Name      string    `json:"name"`
    Status    string    `json:"status"`
    CreatedAt time.Time `json:"created_at"`
}

// ErrorResponse 错误响应
type ErrorResponse struct {
    Error   string `json:"error"`
    Message string `json:"message"`
}

// JSON 发送JSON响应
func JSON(w http.ResponseWriter, statusCode int, data interface{}) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(statusCode)
    json.NewEncoder(w).Encode(data)
}

// Error 发送错误响应
func Error(w http.ResponseWriter, statusCode int, message string, err error) {
    errorMsg := message
    if err != nil {
        errorMsg = err.Error()
    }
    
    JSON(w, statusCode, ErrorResponse{
        Error:   http.StatusText(statusCode),
        Message: errorMsg,
    })
}
```

### 4. 中间件
```go
package middleware

import (
    "context"
    "net/http"
    "time"
    
    "github.com/google/uuid"
)

// Logger 日志记录中间件
func Logger(logger Logger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            start := time.Now()
            
            logger.Info("request started",
                "method", r.Method,
                "path", r.URL.Path,
                "remote_addr", r.RemoteAddr,
            )
            
            wrapped := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
            next.ServeHTTP(wrapped, r)
            
            duration := time.Since(start)
            logger.Info("request completed",
                "method", r.Method,
                "path", r.URL.Path,
                "status", wrapped.statusCode,
                "duration_ms", duration.Milliseconds(),
            )
        })
    }
}

// Recovery 恢复中间件
func Recovery(logger Logger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            defer func() {
                if err := recover(); err != nil {
                    logger.Error("panic recovered", "error", err, "path", r.URL.Path)
                    w.WriteHeader(http.StatusInternalServerError)
                    json.NewEncoder(w).Encode(map[string]string{
                        "error": "internal server error",
                    })
                }
            }()
            
            next.ServeHTTP(w, r)
        })
    }
}
```

### 5. 路由配置
```go
package http

import (
    "net/http"
    "time"
    
    "github.com/go-chi/chi/v5"
    "github.com/go-chi/chi/v5/middleware"
)

// Router 路由器
type Router struct {
    userHandler   *handler.UserHandler
    orderHandler  *handler.OrderHandler
    logger        Logger
    jwtSecret     string
}

// Setup 设置路由
func (rt *Router) Setup() http.Handler {
    r := chi.NewRouter()
    
    // 全局中间件
    r.Use(middleware.RequestID)
    r.Use(mw.Logger(rt.logger))
    r.Use(mw.Recovery(rt.logger))
    r.Use(mw.CORS())
    r.Use(middleware.Timeout(60 * time.Second))
    
    // 健康检查
    r.Get("/health", rt.healthHandler.Health)
    
    // API路由
    r.Route("/api/v1", func(r chi.Router) {
        // 用户路由
        r.Route("/users", func(r chi.Router) {
            r.Post("/", rt.userHandler.CreateUser)
            
            // 需要认证的路由
            r.Group(func(r chi.Router) {
                r.Use(mw.Auth(rt.jwtSecret))
                
                r.Get("/", rt.userHandler.ListUsers)
                r.Get("/{id}", rt.userHandler.GetUser)
                r.Put("/{id}", rt.userHandler.UpdateUser)
                r.Delete("/{id}", rt.userHandler.DeleteUser)
            })
        })
    })
    
    return r
}
```

## 最佳实践

1. **分层清晰**：接口层只负责协议适配
2. **统一响应**：统一的响应格式和错误处理
3. **请求验证**：在接口层验证请求格式
4. **中间件复用**：使用中间件处理通用逻辑
5. **错误转换**：将领域错误转换为HTTP状态码
6. **API版本化**：使用版本前缀管理API
7. **文档生成**：使用Swagger自动生成API文档
